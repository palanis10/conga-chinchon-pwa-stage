<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Conga by Alanis ‚Äî STAGE v3.7.0</title>
<meta name="theme-color" content="#0f1220" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.webmanifest">

<style>
  :root{
    --bg:#0f1220; --card:#171a2b; --muted:#2a2f4a; --text:#e8ecff; --sub:#b8c0ff;
    --accent:#7aa2ff; --accent-2:#4ee1a0; --danger:#ff6b6b; --warn:#ffb020;
    --shadow: 0 8px 24px rgba(0,0,0,.35); --radius:16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Arial, Noto Sans, sans-serif;
    background: radial-gradient(1200px 800px at 20% -10%, #162040, #0d1020 60%) fixed, var(--bg);
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    line-height:1.35;
  }
  .app{max-width:980px; margin:0 auto; padding:6px 12px 120px;}

  /* ===== Header ===== */
  header{
    display:grid;
    grid-template-columns: 1fr auto auto;
    align-items:center;
    gap:10px;
    padding:6px 0 2px 0;
    margin-bottom:8px;
  }
  .brand-wrap{min-width:0}
  .brand{display:flex; flex-direction:column; align-items:flex-start; gap:2px; min-width:0}
  .title{font-weight:900; letter-spacing:.2px; font-size: clamp(18px, 5vw, 26px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .ver{font-weight:800; font-size:12px; color:var(--sub); opacity:.9; line-height:1.1;}
  .lang-pill{
    display:inline-flex; gap:8px; align-items:center;
    border:1px dashed rgba(255,255,255,.18);
    border-radius:999px; padding:6px 10px; height:36px;
    color:var(--text); font-weight:800; letter-spacing:.2px;
    user-select:none;
  }
  .lang-pill button{appearance:none; background:none; border:0; color:inherit; font:inherit; cursor:pointer; opacity:.85;}
  .lang-pill .active{ opacity:1; text-decoration:underline; }
  .iconbtn{width:40px; height:40px; display:grid; place-items:center; border-radius:12px; border:1px solid rgba(255,255,255,.14); background:#0f1428; color:var(--text); cursor:pointer; font-size:18px;}

  /* ===== Card + tools row ===== */
  .card{ background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.0)) , var(--card);
    border:1px solid rgba(255,255,255,.06); border-radius: var(--radius); box-shadow: var(--shadow); padding:10px; }
  .tools{ display:flex; gap:8px; align-items:center; white-space:nowrap; }
  .btn{
    appearance:none; border:0; cursor:pointer; user-select:none;
    padding:10px 12px; border-radius:12px;
    background: linear-gradient(135deg, #1a2344, #121a34);
    border:1px dashed rgba(255,255,255,.22);
    color:var(--text); font-weight:900; letter-spacing:.2px;
    transition:.15s; flex:1 1 0; min-width:0; white-space:nowrap;
    font-size: clamp(12px, 3.4vw, 16px);
  }
  .btn:hover{ filter:brightness(1.07)}
  .btn:active{ transform:translateY(1px)}
  .btn.primary{ background: linear-gradient(135deg, var(--accent), #9f7cff); color:#0b0f1f; border-style:solid; }
  .btn.success{ background: linear-gradient(135deg, var(--accent-2), #9cffc8); color:#001c12; border-style:solid; }

  /* ===== Players ===== */
  .players header{ margin:6px 0 6px 2px; color:var(--sub); font-size:12px; }
  .row{
    display:grid; grid-template-columns: 28px 44px 1fr auto;
    align-items:center; gap:10px; padding:10px; border-radius:14px;
    border:1px solid rgba(255,255,255,.06);
    background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
    margin-bottom:8px;
    user-select: none;
  }
  .drag{ cursor:grab; text-align:center; font-size:18px; color:var(--sub) }
  .drag.locked{ filter:grayscale(1); opacity:.5; cursor:not-allowed }
  .row.dealer{ border-color: rgba(78,225,160,.6); box-shadow: 0 0 0 2px rgba(78,225,160,.25) inset; }
  .avatar{ width:40px; height:40px; border-radius:50%; display:grid; place-items:center; background:#0f1428; border:1px solid rgba(255,255,255,.14); overflow:hidden; font-weight:800; font-size:14px;}
  .row.dealer .avatar{ box-shadow:0 0 0 3px #4ee1a0, 0 0 0 6px rgba(78,225,160,.25); }
  .avatar img{ width:100%; height:100%; object-fit:cover; display:block; }
  .playerName{ min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; line-height:1.1; font-size:20px; font-weight:900; }
  .scorewrap{ display:flex; align-items:center; gap:8px; min-width:86px; justify-content:flex-end; }
  .stars{ color:var(--danger); font-weight:900; font-size:16px; white-space:nowrap; margin-right:2px }
  .score{ font-variant-numeric: tabular-nums; font-weight:900; text-align:right; font-size:22px; }
  .score.over{ color:var(--danger) }

  /* ===== Dialogs ===== */
  dialog{
    width:min(720px, 96vw);
    border-radius:16px; border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)) , #0f1428; color:var(--text);
    box-shadow: 0 24px 64px rgba(0,0,0,.55);
    overflow: hidden;                /* prevents iOS weird jumps */
  }
  dialog::backdrop{ background: rgba(2,6,23,.55) }
  .modal-head{ padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; align-items:center; justify-content:space-between; gap:10px }
  .modal-body{ padding:12px 14px; max-height:70vh; overflow:auto; overscroll-behavior:contain; }
  .modal-foot{ padding:12px 14px; border-top:1px solid rgba(255,255,255,.08); display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap }
  label{font-size:12px; color:var(--sub); display:block; margin-bottom:6px}
  input[type="number"], input[type="text"], select{width:100%; background:#0f1428; border:1px solid var(--muted);
    color:var(--text); padding:9px 10px; border-radius:12px; outline:none; height:38px;}
  input, select, textarea, button { font-size:16px; } /* iOS zoom guard */

  /* Inside dialogs use solid borders for buttons */
  dialog .btn { border-style: solid; }

  /* Accessible toggle switch */
  .switch { position: relative; display: grid; grid-template-columns: 44px 1fr; align-items: center; gap: 10px; }
  .switch input { position: absolute; opacity: 0; width: 0; height: 0; }
  .switch .track { width: 40px; height: 20px; background: var(--muted); border-radius: 999px; transition: .15s; }
  .switch .thumb { position: absolute; width: 18px; height: 18px; left: 1px; top: 1px; border-radius: 50%; background: var(--text); transition: .15s; }
  .switch input:checked + .track { background: var(--accent); }
  .switch input:checked + .track + .thumb { transform: translateX(20px); }
  .switch .switch-label { font-size: 14px; color: var(--text); }

  /* Settings layout */
  #settingsDialog .modal-body { display: flex; flex-direction: column; gap: 12px; }
  #settingsDialog .btn { width: 100%; }

  /* Round dialog */
  .cut-field{ border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:8px; }
  .cut-field legend{ font-size:12px; color:var(--sub); padding:0 6px; }
  .cut-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:6px; }
  .cut-opt{ display:flex; gap:8px; align-items:center; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.00)); padding:6px 8px; border-radius:10px; border:1px solid rgba(255,255,255,.08); }
  .grid-rows{ display:grid; gap:4px }
  .round-row{ display:grid; grid-template-columns: auto 100px 50px; gap:6px; align-items:center;
    padding:4px; border:1px dashed rgba(255,255,255,.15); border-radius:10px;
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.00)); }
  .round-row > div:first-child { display: flex; flex-direction: column; font-size: 14px; }
  .round-row strong { font-size: 16px; }
  .round-row .hint { font-size: 11px; color: var(--sub); }
  .round-row input[type="number"]{ height:30px; padding:4px 8px; font-size:14px; }
  .round-row .minus10{ width:100%; height:30px; border-radius:8px; border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(135deg, #1c243e, #121a34); color:var(--text); font-weight:800; padding:0 2px; font-size:14px; }
  .error{ color:var(--danger); font-weight:700; margin-right:auto }

  /* Win overlay */
  .win-overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(5,8,20,.55); z-index:9999; padding:16px}
  .win-card{ width:min(520px,94vw); border-radius:20px; padding:14px; border:1px solid rgba(255,255,255,.12);
    background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)), #0f1428; box-shadow:0 24px 64px rgba(0,0,0,.55); position:relative; overflow:hidden}
  .win-head{ display:flex; align-items:center; gap:12px}
  .win-photo{ width:56px; height:56px; border-radius:50%; overflow:hidden; border:2px solid #4ee1a0; box-shadow:0 0 0 4px rgba(78,225,160,.25)}
  .win-photo img{ width:100%; height:100%; object-fit:cover}
  .win-name{ font-size:20px; font-weight:900}
  #confettiCanvas{ position:absolute; inset:0; pointer-events:none; z-index:-1; }

  /* ===== Modern Crop dialog ===== */
  #cropDialog { width: min(460px, 92vw); }
  #cropStage { position: relative; width: 100%; height: 360px; border-radius: 16px; background:#0b0f20; border:1px solid rgba(255,255,255,.1); overflow:hidden; touch-action:none; }
  #cropCanvas { position:absolute; inset:0; width:100%; height:100%; }
  .crop-ring { position:absolute; inset:0; pointer-events:none; }
  .crop-controls { display:grid; gap:10px; padding-top:10px; }
  .zoom-row{ display:grid; grid-template-columns: 1fr 60px; align-items:center; gap:10px; }
  .zoom-row input[type="range"]{ width:100% }

  /* Edit dialog extras */
  .avatar-lg{ width:64px; height:64px; border-radius:50%; overflow:hidden; border:1px solid rgba(255,255,255,.14); background:#0f1428; }
  .avatar-lg img{ width:100%; height:100%; object-fit:cover; display:block; }

  /* Responsive */
  @media (max-width: 410px){ .lang-pill{ display:none; } }
  @media (max-width: 400px){
    .modal-head { padding:8px 10px; gap:6px; }
    .modal-body { padding:8px 10px; }
    .modal-foot { padding:8px 10px; gap:6px; }
    .cut-grid{ grid-template-columns: 1fr; }
    .round-row { grid-template-columns: auto 80px 40px; gap:4px; font-size:12px; }
    .round-row strong { font-size:14px; }
    .round-row .hint { font-size:10px; }
    .round-row input[type="number"] { height:28px; padding:2px 6px; font-size:12px; }
    .round-row .minus10 { height:28px; font-size:12px; padding:0; }
  }
</style>
</head>
<body>
<div class="app" id="app">
  <header>
    <div class="brand-wrap">
      <div class="brand">
        <div class="title" id="appTitle">Conga by Alanis</div>
        <div class="ver" id="verLine">STAGE v3.7.0</div>
      </div>
    </div>

    <div class="lang-pill" id="langPill" aria-label="Language">
      <button data-lang="en" id="pillEn" class="active">EN</button><span>/</span>
      <button data-lang="es" id="pillEs">ES</button>
    </div>

    <button id="openSettings" class="iconbtn" aria-label="Settings">‚öôÔ∏è</button>
  </header>

  <section class="card" style="padding:10px; margin-bottom:8px">
    <div class="tools">
      <button id="lockToggle" class="btn" aria-label="Reorder">üîí <span data-i18n="reorder">Reorder</span></button>
      <button id="historyBtn" class="btn"><span data-i18n="history">History</span></button>
      <button id="newRoundBtn" class="btn primary"><span data-i18n="newRound">New round</span></button>
    </div>
    <div id="dealerLine" style="margin-top:6px; font-weight:800; color:var(--sub); font-size:12px"></div>
  </section>

  <section class="players">
    <header><div data-i18n="players">Players</div></header>
    <div id="playersList" role="list" aria-live="polite"></div>
    <button class="btn" id="addPlayerBtn" style="width:100%; margin-top:6px">+ <span data-i18n="addPlayer">Add player</span></button>
  </section>
</div>

<!-- SETTINGS -->
<dialog id="settingsDialog" aria-labelledby="settingsTitle" role="dialog" aria-modal="true">
  <div class="modal-head">
    <div id="settingsTitle" style="font-weight:800" data-i18n="settings">Settings</div>
    <button class="btn" onclick="settingsDialog.close()" style="padding:6px 10px" data-i18n="close">Close</button>
  </div>
  <div class="modal-body">
    <div>
      <label for="limitInput" data-i18n="limitLabel">Limit (default 100)</label>
      <input id="limitInput" type="number" inputmode="numeric" min="1" step="1" />
    </div>

    <label class="switch">
      <input id="autoAdvance" type="checkbox" checked />
      <span class="track" aria-hidden="true"></span>
      <span class="thumb" aria-hidden="true"></span>
      <span class="switch-label" data-i18n="autoAdvance">Auto-advance dealer after round</span>
    </label>

    <label class="switch">
      <input id="lockOrderSwitch" type="checkbox" />
      <span class="track" aria-hidden="true"></span>
      <span class="thumb" aria-hidden="true"></span>
      <span class="switch-label" data-i18n="lockOrder">Lock player reordering</span>
    </label>

    <div style="display:flex; gap:8px; flex-wrap:wrap">
      <button class="btn" id="resetScoresBtn" data-i18n="resetScores">Reset scores</button>
      <button class="btn" id="clearAllBtn" data-i18n="clearAll">Clear all</button>
    </div>
  </div>
  <div class="modal-foot">
    <button class="btn success" onclick="settingsDialog.close()" data-i18n="done">Done</button>
  </div>
</dialog>

<!-- Round dialog -->
<dialog id="roundDialog" aria-labelledby="roundTitle" role="dialog" aria-modal="true">
  <div class="modal-head">
    <div style="flex:1; overflow:hidden;">
      <div id="roundTitle" style="font-weight:800" data-i18n="newRound">New Round</div>
    </div>
    <button class="btn" style="flex-shrink:0; padding:6px 10px" onclick="roundDialog.close()" data-i18n="close">Close</button>
  </div>
  <form id="roundForm" method="dialog">
    <div class="modal-body">
      <fieldset class="cut-field">
        <legend>Who cut? (optional)</legend>
        <div class="cut-grid" id="cutGrid"></div>
      </fieldset>
      <div class="grid-rows" id="roundRows"></div>
    </div>
    <div class="modal-foot">
      <div id="roundError" class="error" style="display:none"></div>
      <button type="button" class="btn" onclick="roundDialog.close()" data-i18n="cancel">Cancel</button>
      <button id="applyRoundBtn" type="submit" class="btn success" data-i18n="apply">Apply</button>
    </div>
  </form>
</dialog>

<!-- Edit player dialog -->
<dialog id="editDialog" aria-labelledby="editTitle" role="dialog" aria-modal="true">
  <div class="modal-head">
    <div id="editTitle" style="font-weight:800" data-i18n="editPlayer">Edit player</div>
    <button class="btn" onclick="editDialog.close()" style="padding:6px 10px" data-i18n="close">Close</button>
  </div>
  <form id="editForm" method="dialog">
    <div class="modal-body">
      <input type="hidden" id="editId" />
      <div style="display:grid; gap:10px">
        <div>
          <label for="editName" data-i18n="name">Name</label>
          <input id="editName" type="text" required />
        </div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
          <div>
            <label for="editScore" data-i18n="score">Score</label>
            <input id="editScore" type="number" step="1" />
          </div>
          <div>
            <label for="editReeng" data-i18n="reenganches">Reenganches</label>
            <input id="editReeng" type="number" step="1" min="0" />
          </div>
        </div>

        <div style="display:grid; gap:10px; margin-top:6px">
          <div>
            <label data-i18n="photo">Photo</label>
            <div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap">
              <div class="avatar-lg"><img id="editAvatarPreview" alt=""></div>
              <div style="display:flex; gap:8px; flex-wrap:wrap">
                <button type="button" class="btn" id="changePhotoBtn" data-i18n="addPhoto">Add photo</button>
                <button type="button" class="btn" id="removePhotoBtn" data-i18n="removePhoto">Remove photo</button>
              </div>
            </div>
          </div>
          <label class="switch">
            <input id="setDealerSwitch" type="checkbox">
            <span class="track" aria-hidden="true"></span>
            <span class="thumb" aria-hidden="true"></span>
            <span class="switch-label" data-i18n="setDealer">Set as next dealer</span>
          </label>
          <div>
            <button type="button" class="btn" id="deletePlayerBtn" data-i18n="deletePlayer">Delete player</button>
          </div>
        </div>
      </div>
    </div>
    <div class="modal-foot">
      <button class="btn" type="button" onclick="editDialog.close()" data-i18n="cancel">Cancel</button>
      <button class="btn success" type="submit" data-i18n="save">Save</button>
    </div>
  </form>
</dialog>

<!-- Modern circle crop dialog -->
<dialog id="cropDialog" aria-labelledby="cropTitle" role="dialog" aria-modal="true">
  <div class="modal-head">
    <div id="cropTitle" style="font-weight:800">Crop Photo</div>
    <button class="btn" onclick="cropDialog.close()" style="padding:6px 10px" data-i18n="close">Close</button>
  </div>
  <div class="modal-body">
    <div id="cropStage">
      <canvas id="cropCanvas"></canvas>
      <!-- overlay ring is drawn in canvas too; this div is kept if we want extra CSS -->
      <div class="crop-ring" aria-hidden="true"></div>
    </div>
    <div class="crop-controls">
      <div class="zoom-row">
        <input id="zoomRange" type="range" min="0" max="100" value="0" step="1" aria-label="Zoom">
        <output id="zoomOut" style="text-align:right; font-variant-numeric:tabular-nums">100%</output>
      </div>
      <div style="display:flex; gap:8px; flex-wrap:wrap">
        <button class="btn" id="pickAnotherBtn">Choose photo</button>
        <button class="btn success" id="applyCropBtn">Apply</button>
      </div>
    </div>
  </div>
</dialog>

<!-- Win overlay -->
<div class="win-overlay" id="winOverlay" aria-live="polite">
  <div class="win-card">
    <canvas id="confettiCanvas"></canvas>
    <div class="win-head">
      <div class="win-photo"><img id="winPhoto" alt=""></div>
      <div>
        <div class="win-name" id="winName">Winner</div>
        <div class="win-sub" id="winSubtitle" data-i18n="winner">WINNER</div>
      </div>
    </div>
    <div class="win-actions" style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px; flex-wrap:wrap">
      <button class="btn success" id="newGameBtn2" data-i18n="newGame">New game</button>
      <button class="btn" id="winCloseBtn" data-i18n="close">Close</button>
    </div>
  </div>
</div>

<audio id="winSound" preload="auto">
  <source type="audio/mp3"
    src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAQAAABgAABcAAABWAAACAAACAQAAAC4AAABfAAAAdwAAAIQAAACkAAAAvwAAAN4AAAD///8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAAAgP8AAP//AP//AP8AAP//AAAAAP8AAP//AP//AP//AP//AP//AP//AAAAAAA="/>
</audio>

<input id="photoInput" type="file" accept="image/*" hidden>

<!-- Player row template (no pencil) -->
<template id="playerRowTpl">
  <div class="row" draggable="true" aria-grabbed="false" title="Long-press to Edit">
    <div class="drag" aria-hidden="true">‚â°</div>
    <div class="avatar" aria-hidden="true"><span class="initials">P</span></div>
    <strong class="playerName">Player</strong>
    <div class="scorewrap">
      <span class="stars" aria-label="Reenganches"></span>
      <span class="score" aria-label="Score"><span class="scoreVal">0</span></span>
    </div>
  </div>
</template>

<script>
(() => {
  "use strict";

  /* ========= Versioning ========= */
  const APP = {
    NAME: "Conga by Alanis",
    CHANNEL: "STAGE",
    VERSION: "3.7.0",
    BUILD: "2025-08-18",
    STORAGE_KEY: "conga_state_v2",
    SCHEMA: 2
  };
  document.title = `${APP.NAME} ‚Äî ${APP.CHANNEL} v${APP.VERSION}`;
  const verLineEl = document.getElementById("verLine");
  if (verLineEl) verLineEl.textContent = `${APP.CHANNEL} v${APP.VERSION}`;

  /* ===== utils ===== */
  const $ = s => document.querySelector(s);
  const on = (sel, ev, fn, opt) => { const el = $(sel); if (el) el.addEventListener(ev, fn, opt||false); };
  const uid=()=> "p"+Math.random().toString(36).slice(2)+Date.now().toString(36);
  const clampInt=(v,d=0)=>Number.isFinite(+v)?Math.trunc(+v):d;
  const initials=(n)=> (n||" ").trim().split(/\s+/).map(s=>s[0]).join("").slice(0,2).toUpperCase();
  const csv=s=>(/[",\n]/.test(s)?'"'+String(s).replace(/"/g,'""')+'"':String(s));
  const todayStr=()=> new Date().toISOString().slice(0,10);
  const toast = (m)=>{ const t=document.createElement('div'); t.className='toast'; t.textContent=m;
    t.style.cssText="position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:#111827;color:#e5e7eb;padding:10px 14px;border-radius:10px;border:1px solid #374151;z-index:99999;font-weight:800;letter-spacing:.2px";
    document.body.appendChild(t); setTimeout(()=>t.remove(),1400); };
  function point(e){ return e && e.touches ? e.touches[0] : e; }

  let saveTimer;
  const debounceSave = () => { clearTimeout(saveTimer); saveTimer = setTimeout(save, 300); };

  const showModalWithLock = (dlg) => {
    if (dlg) {
      document.body.style.overflow = 'hidden';
      dlg.showModal();
      dlg.addEventListener('close', () => { document.body.style.overflow = ''; }, {once: true});
    }
  };

  /* ===== i18n ===== */
  const STR = {
    en:{
      reorder:"Reorder", history:"History", newRound:"New round", players:"Players", addPlayer:"Add player",
      settings:"Settings", language:"Language", limitLabel:"Limit (default 100)", autoAdvance:"Auto-advance dealer after round",
      lockOrder:"Lock player reordering", resetScores:"Reset scores", clearAll:"Clear all",
      done:"Done", roundHint:"Enter points (negatives OK). \"-10\" changes the input.",
      cancel:"Cancel", apply:"Apply", editPlayer:"Edit player", name:"Name", score:"Score", reenganches:"Reenganches",
      photo:"Photo", changePhoto:"Change photo", addPhoto:"Add photo", editPhoto:"Edit photo", removePhoto:"Remove photo", setDealer:"Set as next dealer",
      deletePlayer:"Delete player", save:"Save", winner:"WINNER", close:"Close", newGame:"New game"
    },
    es:{
      reorder:"Reordenar", history:"Historial", newRound:"Nueva ronda", players:"Jugadores", addPlayer:"Agregar jugador",
      settings:"Ajustes", language:"Idioma", limitLabel:"L√≠mite (por defecto 100)", autoAdvance:"Avanzar mano autom√°ticamente",
      lockOrder:"Bloquear reordenamiento", resetScores:"Reiniciar puntajes", clearAll:"Borrar todo",
      done:"Listo", roundHint:"Ingresa puntos (negativos ok). \"-10\" cambia el campo.",
      cancel:"Cancelar", apply:"Aplicar", editPlayer:"Editar jugador", name:"Nombre", score:"Puntos", reenganches:"Reenganches",
      photo:"Foto", changePhoto:"Cambiar foto", addPhoto:"Agregar foto", editPhoto:"Editar foto", removePhoto:"Quitar foto", setDealer:"Fijar como pr√≥ximo mano",
      deletePlayer:"Eliminar jugador", save:"Guardar", winner:"GANADOR", close:"Cerrar", newGame:"Nuevo juego"
    }
  };
  const storageLangKey = "conga_lang";
  let LANG = localStorage.getItem(storageLangKey) || "en";
  function t(k){ return (STR[LANG] && STR[LANG][k]) || STR.en[k] || k; }
  function applyI18n(){
    document.querySelectorAll("[data-i18n]").forEach(n=>{ const key=n.getAttribute("data-i18n"); n.textContent=t(key); });
    $("#pillEn")?.classList.toggle("active", LANG==="en");
    $("#pillEs")?.classList.toggle("active", LANG==="es");
  }

  /* ===== state ===== */
  const STORAGE_KEY = APP.STORAGE_KEY;
  let players=[], limit=100, nextDealerId=null, autoAdvanceDealer=true, gameOver=false;
  let roundCounter=0; let rounds=[]; let lockOrder=false;
  let schema = APP.SCHEMA;

  const defaultsPlayers = () => ([
    {id:uid(), name:"Player 1", score:0, reenganches:0, avatar:null},
    {id:uid(), name:"Player 2", score:0, reenganches:0, avatar:null}
  ]);

  const save=()=>{ 
    const payload = {schema, players,limit,nextDealerId,autoAdvanceDealer,gameOver,roundCounter,rounds,lockOrder, app:{version:APP.VERSION, channel:APP.CHANNEL} };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  };

  function loadLegacyMostRecent(){
    let bestKey=null, bestNum=-1;
    for (let i=0;i<localStorage.length;i++){
      const k=localStorage.key(i);
      const m = /^conga_state_stage_v(\d+)/.exec(k||"");
      if(m){ const n=parseInt(m[1],10); if(n>bestNum){ bestNum=n; bestKey=k; } }
    }
    if(bestKey){
      try { return JSON.parse(localStorage.getItem(bestKey)||"{}"); } catch(e){ return null; }
    }
    return null;
  }

  function migrateIfNeeded(raw){
    const out = { schema: 2,
      players: Array.isArray(raw?.players) && raw.players.length ? raw.players : defaultsPlayers(),
      limit: Number.isFinite(raw?.limit) ? raw.limit : 100,
      autoAdvanceDealer: typeof raw?.autoAdvanceDealer==="boolean" ? raw.autoAdvanceDealer : true,
      nextDealerId: typeof raw?.nextDealerId==="string" ? raw.nextDealerId : (raw?.players?.[0]?.id || null),
      gameOver: !!raw?.gameOver,
      roundCounter: Number.isFinite(raw?.roundCounter) ? raw.roundCounter : 0,
      rounds: Array.isArray(raw?.rounds) ? raw.rounds : [],
      lockOrder: !!raw?.lockOrder,
    };
    return out;
  }

  function load(){
    try{
      const s = JSON.parse(localStorage.getItem(STORAGE_KEY)||"null");
      if (s && typeof s === 'object' && Number.isFinite(s.schema)) {
        ({schema, players,limit,nextDealerId,autoAdvanceDealer,gameOver,roundCounter,rounds,lockOrder} = s);
        if (!Array.isArray(players) || players.length===0) { players=defaultsPlayers(); }
      } else {
        const legacy = loadLegacyMostRecent();
        const m = migrateIfNeeded(legacy || {});
        ({schema, players,limit,nextDealerId,autoAdvanceDealer,gameOver,roundCounter,rounds,lockOrder} = m);
        save();
      }
    }catch(e){
      const m = migrateIfNeeded({});
      ({schema, players,limit,nextDealerId,autoAdvanceDealer,gameOver,roundCounter,rounds,lockOrder} = m);
      save();
    }
  }

  /* ===== render ===== */
  const list=$("#playersList"), rowTpl=$("#playerRowTpl"), dealerLine=$("#dealerLine");
  function render(){
    $("#limitInput").value=limit;
    $("#autoAdvance").checked=autoAdvanceDealer;
    $("#lockOrderSwitch").checked=lockOrder;
    $("#lockToggle").innerHTML = (lockOrder? "üîí " : "üîì ") + t("reorder");
    $("#lockToggle").title = t("reorder");

    if (dealerLine) {
      const dealer = players.find(p=>p.id===nextDealerId);
      dealerLine.textContent = dealer ? `${LANG==='es'?'Pr√≥ximo mano:':'Next dealer:'} ${dealer.name}` : '';
    }

    if(list) {
      const frag = document.createDocumentFragment();
      players.forEach((p, i) => {
        const n=rowTpl.content.firstElementChild.cloneNode(true);
        n.dataset.index=i; n.dataset.id=p.id; n.draggable=!lockOrder;
        n.setAttribute('role','listitem');

        if(!lockOrder){
          n.addEventListener("dragstart",dragStart);
          n.addEventListener("dragover",dragOver);
          n.addEventListener("drop",drop);
          n.addEventListener("dragend",dragEnd);
        }
        attachLongPress(n, ()=>openEdit(p.id));

        if(p.id===nextDealerId) n.classList.add("dealer");
        const avatarBox=n.querySelector(".avatar");
        if(avatarBox){ avatarBox.innerHTML = p.avatar ? `<img alt="" src="${p.avatar}">` : `<span class="initials">${initials(p.name||"")}</span>`; }
        n.querySelector(".playerName").textContent=p.name||"‚Äî";
        const r=clampInt(p.reenganches||0,0); n.querySelector(".stars").textContent = r>0 ? (r===1?"‚òÖ":"‚òÖ "+r) : "";
        const sv=n.querySelector(".scoreVal"); sv.textContent=clampInt(p.score||0);
        const sc=n.querySelector(".score"); if((p.score||0)>=limit+1) sc.classList.add("over"); else sc.classList.remove("over");
        const handle=n.querySelector(".drag"); if(lockOrder){ handle.classList.add("locked"); handle.onclick=()=>toast(t("lockOrder")); } else { handle.classList.remove("locked"); handle.onclick=null; }

        frag.appendChild(n);
      });
      list.innerHTML = "";
      list.appendChild(frag);
    }
    $("#newRoundBtn").disabled=gameOver || players.length===0;
    applyI18n();
    debounceSave();
  }

  function attachLongPress(el, cb){
    let tmr, moved=false;
    const start = (e)=>{ e.preventDefault(); moved=false; tmr=setTimeout(()=>{ if(!moved) cb(); },600); };
    const end = ()=>{ clearTimeout(tmr); };
    el.addEventListener('touchstart', start, {passive:false});
    el.addEventListener('mousedown', start);
    el.addEventListener('touchmove', ()=>{ moved=true; }, {passive:true});
    ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>el.addEventListener(ev, end));
  }

  /* keyboard reorder for accessibility */
  if (list) {
    list.addEventListener('keydown', (e)=>{
      if (e.altKey || e.ctrlKey || e.metaKey) return;
      const row = e.target.closest('.row');
      if (!row || lockOrder) return;
      const idx = +row.dataset.index;
      if (e.key === 'ArrowUp' && idx > 0) {
        const keep = nextDealerId, arr = players.slice(), m = arr.splice(idx,1)[0];
        arr.splice(idx-1,0,m); players=arr; nextDealerId=keep; render(); list.children[idx-1]?.focus(); e.preventDefault();
      } else if (e.key === 'ArrowDown' && idx < players.length-1) {
        const keep = nextDealerId, arr = players.slice(), m = arr.splice(idx,1)[0];
        arr.splice(idx+1,0,m); players=arr; nextDealerId=keep; render(); list.children[idx+1]?.focus(); e.preventDefault();
      }
    });
  }

  /* drag (mouse HTML5 DnD) */
  let dragIdx=null;
  const dragStart=e=>{dragIdx=+e.currentTarget.dataset.index; e.dataTransfer.effectAllowed="move"; e.dataTransfer.setData("text/plain", String(dragIdx)); e.currentTarget.setAttribute("aria-grabbed","true");};
  const dragOver=e=>{e.preventDefault(); e.dataTransfer.dropEffect="move";};
  const drop=e=>{e.preventDefault(); const from=dragIdx!=null?dragIdx:+e.dataTransfer.getData("text/plain"); const to=+e.currentTarget.dataset.index; if(Number.isInteger(from)&&Number.isInteger(to)&&from!==to){ const arr=players.slice(); const m=arr.splice(from,1)[0]; const keep=nextDealerId; arr.splice(to,0,m); players=arr; nextDealerId=keep; render(); }};
  const dragEnd=e=>{e.currentTarget.setAttribute("aria-grabbed","false"); dragIdx=null;};

  /* ===== Edit dialog ===== */
  const editDlg=$("#editDialog"), editForm=$("#editForm");
  function openEdit(id){ const p=players.find(x=>x.id===id); if(!p) return;
    $("#editId").value=p.id; $("#editName").value=p.name||""; $("#editScore").value=clampInt(p.score||0); $("#editReeng").value=clampInt(p.reenganches||0);
    const sds=$("#setDealerSwitch"); if(sds) sds.checked=(p.id===nextDealerId);
    const cp=$("#changePhotoBtn"); if (cp){
      cp.setAttribute("data-i18n", p.avatar ? "editPhoto" : "addPhoto");
      cp.textContent = t(p.avatar ? "editPhoto" : "addPhoto");
      cp.onclick=()=>openCrop(p.id, p.avatar);
    }
    const prev=$("#editAvatarPreview"); if(prev){ prev.src = p.avatar || ""; prev.style.opacity = p.avatar ? "1" : ".35"; }
    $("#removePhotoBtn").onclick = ()=>{ p.avatar=null; render(); const prev=$("#editAvatarPreview"); if(prev){ prev.src=""; prev.style.opacity=".35"; } };
    $("#deletePlayerBtn").onclick = ()=>{ if(confirm(LANG==="es"?"¬øEliminar jugador?":"Delete this player?")){ editDlg.close(); removePlayer(p.id); }};
    showModalWithLock(editDlg);
  }
  if(editForm) editForm.addEventListener("submit", (e)=>{
    e.preventDefault(); const id=$("#editId").value; const p=players.find(x=>x.id===id); if(!p) return editDlg && editDlg.close();
    p.name=String($("#editName").value||"").trim()||p.name; p.score=clampInt($("#editScore").value, p.score); p.reenganches=Math.max(0, clampInt($("#editReeng").value, p.reenganches));
    const sds=$("#setDealerSwitch"); if(sds && sds.checked) nextDealerId=p.id; editDlg && editDlg.close(); render();
  });

  /* ===== Modern Circle Crop (pan + slider zoom) ===== */
  const cropDlg=$("#cropDialog"), cropStage=$("#cropStage"), cropCanvas=$("#cropCanvas"), zoomRange=$("#zoomRange"), zoomOut=$("#zoomOut"), pickAnotherBtn=$("#pickAnotherBtn"), applyCropBtn=$("#applyCropBtn"), photoInput=$("#photoInput");
  const ctx = cropCanvas.getContext('2d');

  // crop state
  let cropPlayerId=null;
  let img = new Image();
  let imgLoaded=false;
  let scale=1, minScale=1, maxScale=4; // image scale
  let offsetX=0, offsetY=0;           // image top-left in canvas coords
  let startPanX=0, startPanY=0, panning=false;
  let pinchDist0=null, scale0=null;

  function dprSize(el){ const DPR = window.devicePixelRatio || 1; return [el.clientWidth*DPR, el.clientHeight*DPR, DPR]; }

  function circleSpecs(){
    // big responsive circle with 12px padding
    const w = cropCanvas.width, h = cropCanvas.height;
    const DPR = window.devicePixelRatio || 1;
    const pad = 12*DPR;
    const r = Math.min(w, h)/2 - pad;
    const cx = w/2, cy = h/2;
    return {cx, cy, r, DPR};
  }

  function coverMinScale(){
    // ensure image fully covers the circle
    const {r} = circleSpecs();
    const needW = 2*r, needH = 2*r;
    const s = Math.max(needW / img.width, needH / img.height);
    return s * 1.001;  // tiny safety
  }

  function clampPan(){
    const {cx, cy, r} = circleSpecs();
    const displayW = img.width * scale;
    const displayH = img.height * scale;

    // image must cover circle: left<=cx-r, top<=cy-r, right>=cx+r, bottom>=cy+r
    const minX = cx - r - displayW;
    const maxX = cx + r - 0;
    const minY = cy - r - displayH;
    const maxY = cy + r - 0;

    offsetX = Math.min(Math.max(offsetX, minX), maxX - displayW + displayW); // simplified clamp using inequalities above
    offsetY = Math.min(Math.max(offsetY, minY), maxY - displayH + displayH);

    // Better, compute exact clamping:
    if (offsetX > cx - r) offsetX = cx - r;
    if (offsetY > cy - r) offsetY = cy - r;
    if (offsetX + displayW < cx + r) offsetX = (cx + r) - displayW;
    if (offsetY + displayH < cy + r) offsetY = (cy + r) - displayH;
  }

  function drawCrop(){
    // size canvas correctly
    const [cw, ch, DPR] = dprSize(cropStage);
    if (cropCanvas.width !== cw || cropCanvas.height !== ch){
      cropCanvas.width = cw; cropCanvas.height = ch;
    }
    ctx.clearRect(0,0,cw,ch);

    const {cx, cy, r} = circleSpecs();

    if (imgLoaded){
      const w = img.width * scale;
      const h = img.height * scale;
      ctx.drawImage(img, offsetX, offsetY, w, h);
    }

    // dark overlay with circular cutout + green ring
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.beginPath(); ctx.rect(0,0,cw,ch);
    ctx.moveTo(cx+r, cy);
    ctx.arc(cx, cy, r, 0, Math.PI*2, true);
    ctx.fill('evenodd');
    ctx.restore();

    // ring
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-2') || '#4ee1a0';
    ctx.lineWidth = Math.max(2, r*0.04);
    ctx.stroke();
    ctx.restore();
  }

  function setZoomBySlider(val){
    // val 0..100
    const t = val/100;
    scale = minScale + (maxScale - minScale)*t;
    zoomOut.textContent = Math.round(scale/minScale*100) + '%';
    clampPan();
    drawCrop();
  }

  function openCrop(playerId, existingAvatar=null){
    cropPlayerId = playerId;

    const useImage = (src) => {
      imgLoaded=false;
      img = new Image();
      img.onload = ()=>{
        imgLoaded = true;
        // init sizing and center
        minScale = coverMinScale();
        maxScale = Math.max(minScale*4, minScale+0.01);
        scale = minScale * 1.05;
        const {cx, cy} = circleSpecs();
        const w = img.width * scale, h = img.height * scale;
        offsetX = cx - w/2; offsetY = cy - h/2;
        clampPan();
        // sync slider
        const t = (scale - minScale)/(maxScale - minScale);
        zoomRange.value = Math.round(t*100);
        zoomOut.textContent = Math.round(scale/minScale*100)+'%';
        drawCrop();
        // ensure we see the top of dialog / no jump
        cropDialog.scrollTop = 0;
      };
      img.src = src;
    };

    if (existingAvatar){
      // open immediately with current avatar; provide "Choose photo" to replace
      showModalWithLock(cropDlg);
      // wait a frame to size canvas before load (avoids 0x0 sizing on iOS)
      requestAnimationFrame(()=>{ drawCrop(); useImage(existingAvatar); });
    } else {
      // choose a new photo then open
      photoInput.onchange = async () => {
        const file = photoInput.files[0];
        if (!file) return;
        const dataUrl = await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); });
        showModalWithLock(cropDlg);
        requestAnimationFrame(()=>{ drawCrop(); useImage(dataUrl); });
      };
      photoInput.click();
    }
  }

  // pointer handlers (pan + pinch)
  const activeTouches = new Map();
  cropStage.addEventListener('pointerdown', (e)=>{
    cropStage.setPointerCapture(e.pointerId);
    activeTouches.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (activeTouches.size===2){
      // pinch start
      const pts = [...activeTouches.values()];
      pinchDist0 = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      scale0 = scale;
    } else if (activeTouches.size===1){
      panning = true;
      startPanX = e.clientX - offsetX;
      startPanY = e.clientY - offsetY;
    }
  });
  cropStage.addEventListener('pointermove', (e)=>{
    if (!imgLoaded) return;
    if (!activeTouches.has(e.pointerId)) return;
    activeTouches.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if (activeTouches.size===2){
      const pts = [...activeTouches.values()];
      const dist = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      if (pinchDist0 && scale0){
        const ratio = dist / pinchDist0;
        scale = Math.min(maxScale, Math.max(minScale, scale0 * ratio));
        const t = (scale - minScale)/(maxScale - minScale);
        zoomRange.value = Math.round(t*100);
        zoomOut.textContent = Math.round(scale/minScale*100)+'%';
        clampPan(); drawCrop();
      }
    } else if (panning){
      offsetX = e.clientX - startPanX;
      offsetY = e.clientY - startPanY;
      clampPan(); drawCrop();
    }
  });
  function endPointer(e){ activeTouches.delete(e.pointerId); if (activeTouches.size<2){ pinchDist0=null; scale0=null; } if (activeTouches.size===0){ panning=false; } }
  cropStage.addEventListener('pointerup', endPointer);
  cropStage.addEventListener('pointercancel', endPointer);
  cropStage.addEventListener('pointerleave', endPointer);

  // slider zoom
  zoomRange.addEventListener('input', (e)=> setZoomBySlider(+e.target.value));

  // pick another
  pickAnotherBtn.addEventListener('click', ()=>{
    photoInput.onchange = async () => {
      const file = photoInput.files[0];
      if (!file) return;
      try{
        const dataUrl = await new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); });
        imgLoaded=false;
        requestAnimationFrame(()=>{ drawCrop(); openCrop(cropPlayerId, dataUrl); });
      }catch{ toast('Photo load error'); }
    };
    photoInput.click();
  });

  // export (hi-res circle)
  applyCropBtn.addEventListener('click', ()=>{
    if (!imgLoaded) { cropDlg.close(); return; }
    const {cx, cy, r} = circleSpecs();
    // map circle center to original image coordinates
    const ox = (cx - offsetX) / scale;
    const oy = (cy - offsetY) / scale;
    const or = r / scale;

    const size = 512; // output
    const out = document.createElement('canvas');
    out.width = size; out.height = size;
    const octx = out.getContext('2d');
    octx.clearRect(0,0,size,size);
    octx.save();
    // clip circle
    octx.beginPath(); octx.arc(size/2, size/2, size/2, 0, Math.PI*2); octx.clip();
    // scale so that radius or maps to size/2
    const S = (size/2) / or;
    octx.setTransform(S,0,0,S, size/2 - ox*S, size/2 - oy*S);
    octx.imageSmoothingQuality = 'high';
    octx.drawImage(img, 0,0);
    octx.restore();
    const dataOut = out.toDataURL('image/png', 0.95);

    const p = players.find(x=>x.id===cropPlayerId);
    if (p){ p.avatar = dataOut; render(); }
    cropDlg.close();
  });

  /* ===== Round dialog (cutter + threshold 101+) ===== */
  const roundDlg=$("#roundDialog"), rows=$("#roundRows"), rErr=$("#roundError"), applyBtn=$("#applyRoundBtn"), cutGrid=$("#cutGrid");
  let selectedCutterId = "";

  function buildCutterGrid(){
    cutGrid.innerHTML = "";
    const makeOpt = (id,label,checked=false)=>{
      const wrap=document.createElement("label");
      wrap.className="cut-opt";
      const input=document.createElement("input");
      input.type="radio"; input.name="cutter"; input.value=id; input.checked=checked;
      const span=document.createElement("span"); span.textContent=label;
      wrap.append(input,span);
      input.addEventListener('change', validateRound);
      return wrap;
    };
    cutGrid.appendChild(makeOpt("", LANG==='es'?'Nadie':'None', true));
    players.forEach(p=> cutGrid.appendChild(makeOpt(p.id, p.name, false)));
  }

  const openRound=()=>{ 
    if(!roundDlg||!rows) return; 
    if(players.length===0){ toast(LANG==="es"?"Agrega jugadores primero":"Add players first"); return; } 
    rows.innerHTML="";
    buildCutterGrid();
    selectedCutterId = "";

    const frag = document.createDocumentFragment();
    players.forEach(p=>{ 
      const r=document.createElement("div"); r.className="round-row";
      const name=document.createElement("div"); name.innerHTML=`<strong>${p.name}</strong><div class="hint">${t("score")}: ${p.score||0}</div>`;
      const inp=document.createElement("input"); inp.id="rr_"+p.id; inp.type="number"; inp.step="1"; inp.inputMode="numeric"; inp.placeholder="0"; inp.dataset.pid=p.id;
      inp.addEventListener('input', validateRound);
      const minus=document.createElement("button"); minus.type="button"; minus.className="minus10"; minus.textContent="-10"; minus.onclick=()=>{ inp.value=clampInt((inp.value===""?0:+inp.value)-10); validateRound(); };
      r.append(name,inp,minus); frag.appendChild(r);
    });
    rows.appendChild(frag);
    rErr.style.display="none"; applyBtn.disabled=false;

    // Open first, then focus without scrolling + force dialog to top (prevents iOS jump)
    showModalWithLock(roundDlg);
    requestAnimationFrame(()=>{
      roundDlg.scrollTop = 0;
      rows.scrollTop = 0;
      rows.querySelector('input')?.focus({preventScroll:true});
    });
  };

  function roundInputs(){
    const m={}; 
    for(const p of players){ const el=$("#rr_"+p.id); m[p.id]=clampInt(el && el.value!=="" ? el.value : 0,0);} 
    return m; 
  }

  function validateRound(){
    const inputs = roundInputs();
    const radios = document.querySelectorAll('input[name="cutter"]');
    radios.forEach(r=>{ if(r.checked) selectedCutterId = r.value; });
    if (!selectedCutterId) { rErr.style.display="none"; applyBtn.disabled=false; return; }
    const cutter = players.find(p=>p.id===selectedCutterId);
    if (!cutter){ rErr.style.display="none"; applyBtn.disabled=false; return; }
    const projected = clampInt(cutter.score||0) + clampInt(inputs[cutter.id]||0);
    if (projected > limit){
      rErr.textContent = LANG==='es' ? `El que corta no puede pasar de ${limit}. (ser√≠an ${projected})` : `Cutter cannot exceed ${limit}. (would be ${projected})`;
      rErr.style.display="block"; applyBtn.disabled=true; 
    } else { rErr.style.display="none"; applyBtn.disabled=false; }
  }

  function snapshotTotalsById(){ const o={}; for(const p of players) o[p.id]=clampInt(p.score||0); return o; }

  function applyRound(inputs){
    const roundNo = roundCounter + 1;
    const proj = {}; players.forEach(p => proj[p.id] = clampInt(p.score||0) + clampInt(inputs[p.id]||0));

    if (selectedCutterId){
      const cutterProj = proj[selectedCutterId] || 0;
      if (cutterProj > limit){ validateRound(); return; }
      const others = players.filter(p=>p.id!==selectedCutterId);
      const allOthersOver = others.every(p => proj[p.id] > limit);
      const cutterEligible = cutterProj <= limit;
      if (cutterEligible && allOthersOver){
        players.forEach(p=>{ p.score = proj[p.id]; });
        roundCounter += 1;
        rounds.push({round:roundNo, inputs:{...inputs}, totals:snapshotTotalsById(), timestamp:Date.now(), cutter:selectedCutterId, instantWin:true});
        gameOver=true;
        showWinOverlay(players.find(p=>p.id===selectedCutterId));
        render();
        return;
      }
    }

    // Reenganche only at limit+1 or higher
    roundCounter += 1;
    const REENG_THRESHOLD = limit + 1;
    const under = players.filter(p => proj[p.id] <= limit);
    const over  = players.filter(p => proj[p.id] >= REENG_THRESHOLD);

    if (under.length >= 2 && over.length > 0) {
      const maxUnderVal = Math.max(...under.map(p => proj[p.id]));
      over.forEach(p => {
        proj[p.id] = maxUnderVal;
        p.reenganches = (p.reenganches || 0) + 1;
      });
    } else if (under.length === 0) {
      players.forEach(p => { proj[p.id] = Math.min(proj[p.id], limit); });
      toast(LANG==="es"?"Todos excedieron - limitado":"All over limit - capped");
    }

    players.forEach(p=>{ p.score=proj[p.id]; });

    if(autoAdvanceDealer && players.length > 0 && nextDealerId){ 
      const i=players.findIndex(p=>p.id===nextDealerId); 
      nextDealerId=players[(i>=0&&i<players.length-1)?i+1:0].id; 
    }

    rounds.push({round:roundNo, inputs:{...inputs}, totals:snapshotTotalsById(), timestamp:Date.now(), cutter:selectedCutterId||""});
    gameOver=false;

    const alive = players.filter(p=>p.score<=limit);
    if(alive.length===1){
      gameOver=true;
      showWinOverlay(alive[0]);
    }
    render();
  }

  $("#roundForm")?.addEventListener("submit", (e)=>{ e.preventDefault(); const inputs = roundInputs(); applyRound(inputs); roundDlg && roundDlg.close(); });

  /* ===== History modal ===== */
  function openRoundsTable(){
    const dlg=document.createElement('dialog');
    dlg.innerHTML = `<div class="modal-head"><div style="font-weight:800">${t("history")}</div><button class="btn" style="padding:6px 10px" data-i18n="close">${t("close")}</button></div><div class="modal-body"><div class="table-wrap"></div></div>`;
    const twrap=dlg.querySelector('.table-wrap');
    const table=document.createElement('table'); const thead=document.createElement('thead'); const trh=document.createElement('tr');
    trh.innerHTML = "<th>#</th>"+players.map(p=>`<th>${p.name} (Œî / Total)</th>`).join(""); thead.appendChild(trh); table.appendChild(thead);
    const tbody=document.createElement('tbody');
    rounds.forEach(r=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`<th>${r.round}${r.instantWin?' ‚≠ê':''}</th>`+players.map(p=>`<td>${(r.inputs&&r.inputs[p.id]!=null)?r.inputs[p.id]:"0"} / ${(r.totals&&r.totals[p.id]!=null)?r.totals[p.id]:"0"}</td>`).join("");
      tbody.appendChild(tr);
    });
    table.appendChild(tbody); twrap.appendChild(table);

    const exportBtn = document.createElement('button');
    exportBtn.className = 'btn';
    exportBtn.textContent = LANG==='es' ? 'Exportar CSV' : 'Export CSV';
    exportBtn.style.margin = '8px 0 0 auto';
    exportBtn.onclick = () => {
      const headers = ['Round', ...players.map(p => `${p.name} (Œî,Total)`)];
      const rowsCsv = rounds.map(r => {
        const cols = [r.round + (r.instantWin?'*':'')];
        players.forEach(p => {
          const delta = (r.inputs && r.inputs[p.id] != null) ? r.inputs[p.id] : 0;
          const tot   = (r.totals && r.totals[p.id] != null) ? r.totals[p.id] : 0;
          cols.push(`${delta},${tot}`);
        });
        return cols.map(csv).join(',');
      });
      const out = [headers.map(csv).join(','), ...rowsCsv].join('\n');
      const blob = new Blob([out], {type:'text/csv;charset=utf-8;'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `conga_rounds_${todayStr()}.csv`;
      a.click();
      URL.revokeObjectURL(a.href);
    };

    dlg.querySelector(".modal-body").appendChild(exportBtn);
    dlg.querySelector("button").onclick=()=>dlg.close(); document.body.appendChild(dlg); 
    showModalWithLock(dlg);
  }

  /* ===== Wire-up ===== */
  on("#openSettings","click", ()=> { showModalWithLock($("#settingsDialog")); });
  on("#historyBtn","click", openRoundsTable);
  on("#newRoundBtn","click", openRound);
  on("#addPlayerBtn","click", ()=>{ const name=prompt(LANG==="es"?"¬øNombre del jugador?":"Player name?"); if(name!==null){ addPlayer(String(name).trim()||undefined); } });
  on("#resetScoresBtn","click", ()=>{ if(players.length&&confirm(LANG==="es"?"¬øReiniciar puntajes y reenganches?":"Reset all scores and reenganches?")){ players.forEach(p=>{p.score=0;p.reenganches=0;}); gameOver=false; render(); } });
  on("#clearAllBtn","click", ()=>{ if(confirm(LANG==="es"?"¬øBorrar todo?":"Clear all players and settings?")){ 
      players = defaultsPlayers();
      limit=100; nextDealerId=players[0].id; autoAdvanceDealer=true; gameOver=false;
      rounds=[]; roundCounter=0; lockOrder=false;
      render();
    }});
  on("#lockToggle","click", ()=>{ lockOrder=!lockOrder; const sw=$("#lockOrderSwitch"); if(sw) sw.checked=lockOrder; render(); });
  on("#lockOrderSwitch","change", e=>{ lockOrder=!!e.target.checked; render(); });
  on("#limitInput","input", e=>{ const v=clampInt(e.target.value,limit); limit=Math.max(1,v); render(); });
  on("#autoAdvance","change", e=>{ autoAdvanceDealer=!!e.target.checked; render(); });

  const addPlayer=(name="")=>{ const p={id:uid(), name:name||("Player "+(players.length+1)), score:0, reenganches:0, avatar:null}; players.push(p); if(!nextDealerId && players[0]) nextDealerId=players[0].id; gameOver=false; render(); };
  const removePlayer=id=>{ const i=players.findIndex(p=>p.id===id); if(i<0) return; const was=players[i].id===nextDealerId; players.splice(i,1); if(!players.length) nextDealerId=null; else if(was) nextDealerId=players[Math.min(i,players.length-1)].id; render(); };

  /* ===== Win overlay ===== */
  let confettiRaf;
  function showWinOverlay(winner){
    const ov=$("#winOverlay"); if(!ov) return;
    $("#winName").textContent = winner?.name || 'Winner';
    $("#winPhoto").src = winner?.avatar || '';
    document.body.style.overflow = 'hidden';
    ov.style.display='flex';
    try{ $("#winSound").play().catch(()=>{});}catch{}
    startConfetti();
  }
  $("#winCloseBtn")?.addEventListener('click', ()=>{ $("#winOverlay").style.display='none'; stopConfetti(); document.body.style.overflow = ''; });
  $("#newGameBtn2")?.addEventListener('click', ()=>{ players.forEach(p=>{p.score=0;p.reenganches=0;}); gameOver=false; rounds=[]; roundCounter=0; $("#winOverlay").style.display='none'; stopConfetti(); document.body.style.overflow = ''; render(); window.scrollTo({top:0,behavior:"smooth"}); });

  function stopConfetti() { if (confettiRaf) cancelAnimationFrame(confettiRaf); }
  function startConfetti(){ const c=$("#confettiCanvas"); if(!c) return; const ctx=c.getContext('2d'); const DPR=window.devicePixelRatio||1;
    const W=c.parentElement.clientWidth, H=c.parentElement.clientHeight; c.width=W*DPR; c.height=H*DPR; ctx.scale(DPR,DPR);
    const N=80;
    const pieces=Array.from({length:N},()=>({x:Math.random()*W, y:-10-Math.random()*H, r:2+Math.random()*4, vy:2+Math.random()*3, vx:-1+Math.random()*2, a:Math.random()*Math.PI*2, color: `hsl(${Math.floor(Math.random()*360)},90%,60%)`}));
    const tick=()=>{ ctx.clearRect(0,0,W,H);
      pieces.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.a+=0.1; if(p.y>H+20){ p.y=-20; p.x=Math.random()*W; } ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.a); ctx.fillStyle=p.color; ctx.fillRect(-p.r,-p.r,p.r*2,p.r*2); ctx.restore(); });
      confettiRaf=requestAnimationFrame(tick);
    }; stopConfetti(); tick();
    setTimeout(stopConfetti, 5000);
  }

  /* ===== Lang toggles ===== */
  $("#pillEn")?.addEventListener("click", ()=>{ LANG="en"; localStorage.setItem(storageLangKey,LANG); applyI18n(); render(); });
  $("#pillEs")?.addEventListener("click", ()=>{ LANG="es"; localStorage.setItem(storageLangKey,LANG); applyI18n(); render(); });

  // init
  load();
  applyI18n();
  render();
})();
</script>
</body>
</html>
